###
Environment information
===
There are 15 cities.
Depot city 0: (54, 87)
City 1: (21, 84)
City 2: (69, 84)
City 3: (53, 40)
City 4: (54, 42)
City 5: (36, 30)
City 6: (52, 82)
City 7: (93, 44)
City 8: (21, 78)
City 9: (68, 14)
City 10: (51, 28)
City 11: (44, 79)
City 12: (56, 58)
City 13: (72, 43)
City 14: (6, 99)
###

###
Robot information
===
There is one robot.
- The robot start at depot city 0. 
- The robot can travel between any two cities. 
- The travel cost is calculated as the Euclidean distance between the two cities.
###

###
Task
===
The robot needs to visit exactly 8 cities, including the depot city, starting and ending at the depot city.
The goal is to find the shortest possible tour that visits exactly 8 cities out of the given set of cities.
You can refer to the pseudocode provided below to solve the problem:
****

\section*{Summary of General Variable Neighborhood Search (GVNS) Algorithm (Algorithm 3)}

The GVNS algorithm is designed for solving the k-traveling salesman problem (k-TSP). It systematically explores different neighborhood structures to find a near-optimal solution. The algorithm iterates through local search procedures and shaking processes to escape local optima and improve the solution quality.

\subsection*{Key Components and Subroutines}

\subsubsection*{Solution Encoding and Fitness}
\begin{itemize}
    \item \textbf{Solution Encoding}: Solutions are represented by a linear permutation of $k$ cities, with the home city always occupying the first position.
    \item \textbf{Fitness Function}: The objective function of the k-TSP is the total length of the tour, which is minimized. The fitness of a solution is the total distance traveled.
\end{itemize}

\subsubsection*{Initial Solution Generation}
A random initial solution is generated by iteratively inserting unvisited cities into random positions in the tour until all $k$ cities are visited.

\subsubsection*{Variable Neighborhood Descent (VND)}
\begin{itemize}
    \item \textbf{Neighborhood Structures}:
        \begin{itemize}
            \item \textbf{N1 (Subset Selection)}: Involves exchanging a visited city with an unvisited city. This neighborhood is explored by removing a visited city from the tour and adding an unvisited city at the best possible position.
            \item \textbf{N2 (Permutation)}: Involves swapping the positions of two visited cities in the tour.
        \end{itemize}
    \item \textbf{First Improvement Strategy}: VND follows the first improvement strategy, where it immediately adopts a better solution found in the neighborhood exploration.
\end{itemize}

\subsubsection*{GVNS Algorithm Steps}
\begin{itemize}
    \item \textbf{Initialization}: Start with an initial solution and set the neighborhood indicator.
    \item \textbf{Shaking}: Generate a random solution in the current neighborhood to diversify the search.
    \item \textbf{Local Search}: Apply VND to improve the solution within the neighborhood.
    \item \textbf{Acceptance Criteria}: If the new solution is better than the current solution, update the current solution and reset the neighborhood indicator.
    \item \textbf{Termination}: The process repeats until a stopping criterion (e.g., a maximum number of iterations or time limit) is met.
\end{itemize}


\subsection*{Detailed Pseudo-code for GVNS Algorithm}

\begin{algorithm}
\caption{GVNS for k-TSP}
\label{alg:GVNS}
\begin{algorithmic}[1]
\STATE \textbf{Input:} Number of restarts $Nrst$, set of cities $V$, distance matrix $D$
\STATE \textbf{Output:} Best solution found

\STATE Initialize best solution $S_{\text{best}}$

\FOR{$i = 1$ to $Nrst$}
    \STATE $S \gets \text{GenerateInitialSolution}(V)$
    \REPEAT
        \STATE $S' \gets \text{Shake}(S)$
        \STATE $S'' \gets \text{VND}(S', N1, N2)$
        \IF{$f(S'') < f(S)$}
            \STATE $S \gets S''$
            \STATE Reset neighborhood indicator
        \ELSE
            \STATE Move to next neighborhood structure
        \ENDIF
    \UNTIL{termination criterion met}
    \IF{$f(S) < f(S_{\text{best}})$}
        \STATE $S_{\text{best}} \gets S$
    \ENDIF
\ENDFOR
\STATE \textbf{return} $S_{\text{best}}$
\end{algorithmic}
\end{algorithm}

\subsection*{Explanation of Subroutines}

\subsubsection*{GenerateInitialSolution(V)}
This function generates a random initial solution by placing the home city in the first position and iteratively adding unvisited cities to random positions until the solution is complete.

\subsubsection*{Shake(S)}
This function perturbs the solution by moving to a random solution within the current neighborhood structure to escape local optima and explore new areas of the search space.

\subsubsection*{VND(S', N1, N2)}
This function applies the Variable Neighborhood Descent algorithm to improve the solution. It explores the N1 and N2 neighborhoods using the first improvement strategy, where the search moves to a new solution as soon as a better solution is found.

By systematically exploring different neighborhoods and combining local search with shaking procedures, the GVNS algorithm effectively finds high-quality solutions for the k-TSP.


****
###

###
Format requirements
===
1) Please output the tour as a list of city indices. The tour should start and end at the depot city 0.
2) Please output the total travel cost of the tour.

For example, if the tour is 0 -> 1 -> 2 -> 3 -> 0 and the total travel cost is 100, then the output should be: 

Tour: [0, 1, 2, 3, 0]
Total travel cost: 100
###