import numpy as np
import random
from scipy.spatial.distance import euclidean

# Initialize parameters
cities = {
    0: (30, 40), 1: (37, 52), 2: (49, 49), 3: (52, 64),
    4: (31, 62), 5: (52, 33), 6: (42, 41), 7: (52, 41),
    8: (57, 58), 9: (62, 42), 10: (42, 57), 11: (27, 68),
    12: (43, 67), 13: (58, 48), 14: (58, 27), 15: (37, 69)
}
depot_indices = list(range(8))  # Depot cities are from index 0 to 7
city_indices = list(range(8, 16))  # Other cities are from index 8 to 15

# Distance matrix calculation
n_cities = len(cities)
dist_matrix = np.zeros((n_cities, n_cities))
for i in range(n_cities):
    for j in range(n_cities):
        if i != j:
            dist_matrix[i][j] = euclidean(cities[i], cities[j])
        else:
            dist_matrix[i][j] = float('inf')

# Ant Colony Optimization Parameters
antnum = 32
cyclenum = 100
inittrail = 1.0
alpha = 1
beta = 5
rho = 0.5

# Pheromone matrix
pheromone = np.full((n_cities, n_cities), inittrail)

def visibility(i, j):
    """ Calculating the visibility, which is the inverse of the distance """
    return 1.0 / dist_matrix[i][j] if i != j else 0

def calculate_probability(from_city, allowed):
    """ Calculate transition probabilities """
    denom = sum([pheromone[from_city][j] ** alpha * visibility(from_city, j) ** beta for j in allowed])
    probs = {j: (pheromone[from_city][j] ** alpha * visibility(from_city, j) ** beta) / denom for j in allowed}
    return probs

def select_next_city(current_city, allowed_cities):
    """ Select the next city based on transition probabilities """
    probabilities = calculate_probability(current_city, allowed_cities)
    next_city = random.choices(list(probabilities.keys()), weights=list(probabilities.values()), k=1)[0]
    return next_city

def create_tour(depot):
    """ Create a tour for one ant, starting and ending at the designated depot """
    tour = [depot]
    allowed = city_indices.copy()  # Start with all non-depot cities allowed
    current_city = depot

    while allowed:
        next_city = select_next_city(current_city, allowed)
        tour.append(next_city)
        allowed.remove(next_city)
        current_city = next_city

    tour.append(depot)  # Return to depot
    return tour

def update_pheromone(ants):
    """ Update pheromone trails based on tours generated by all ants """
    global pheromone
    pheromone *= (1 - rho)  # Evaporation
    for tour in ants:
        tour_length = calculate_tour_length(tour)
        contribution = 1.0 / tour_length
        for i in range(len(tour)-1):
            pheromone[tour[i]][tour[i+1]] += contribution
            pheromone[tour[i+1]][tour[i]] += contribution  # Since it's symmetric

def calculate_tour_length(tour):
    """ Calculate the total length of a given tour """
    return sum([dist_matrix[tour[i]][tour[i+1]] for i in range(len(tour)-1)])

# Main ACO cycle

lowest_cost = float('inf')
best_solution = []

for cycle in range(cyclenum):
    ants = [create_tour(random.choice(depot_indices)) for _ in range(antnum)]
    current_best = min(ants, key=calculate_tour_length)
    current_best_cost = calculate_tour_length(current_best)
    
    if current_best_cost < lowest_cost:
        lowest_cost = current_best_cost
        best_solution = current_best

    update_pheromone(ants)  # Update pheromone based on all ants generated in this cycle

# Output the final best solution
print(f"Best Tour: {best_solution}")
print(f"Best Tour Total Travel Cost: {lowest_cost}")